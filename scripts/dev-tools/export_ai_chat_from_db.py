#!/usr/bin/env python3
"""
从指定的 Cursor state.vscdb 中提取 aiService.generations / aiService.prompts，
导出“今天 11:00–23:00”时间窗内的聊天记录到指定目录（Markdown）。

用法示例：
    python3 scripts/export_ai_chat_from_db.py "/path/to/state.vscdb" "/path/to/output_dir"
"""

import json
import os
import sqlite3
import sys
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, List, Optional


LOCAL_TZ = timezone(timedelta(hours=8))  # 近似认为是北京时间


def table_exists(conn: sqlite3.Connection, name: str) -> bool:
    cur = conn.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name=?;", (name,)
    )
    return cur.fetchone() is not None


def connect_db(path: str) -> sqlite3.Connection:
    if not os.path.exists(path):
        raise FileNotFoundError(f"state.vscdb not found at: {path}")
    uri = f"file:{path}?mode=ro"
    return sqlite3.connect(uri, uri=True)


def get_key_value(
    conn: sqlite3.Connection, key: str
) -> Optional[str]:
    """
    从 cursorDiskKV 或 ItemTable 中读取指定 key 的 value（优先 cursorDiskKV）。
    返回解码为 str 的 JSON 文本，若不存在则返回 None。
    """
    # 1) cursorDiskKV
    if table_exists(conn, "cursorDiskKV"):
        try:
            cur = conn.execute(
                "SELECT value FROM cursorDiskKV WHERE key=? LIMIT 1;", (key,)
            )
            row = cur.fetchone()
            if row is not None:
                value = row[0]
                if isinstance(value, bytes):
                    return value.decode("utf-8", errors="ignore")
                return str(value)
        except Exception:
            pass

    # 2) ItemTable（如果有 key/value 列）
    if table_exists(conn, "ItemTable"):
        try:
            cur = conn.execute("PRAGMA table_info(ItemTable);")
            cols = [r[1] for r in cur.fetchall()]
            if "key" in cols and "value" in cols:
                cur = conn.execute(
                    "SELECT value FROM ItemTable WHERE key=? LIMIT 1;", (key,)
                )
                row = cur.fetchone()
                if row is not None:
                    value = row[0]
                    if isinstance(value, bytes):
                        return value.decode("utf-8", errors="ignore")
                    return str(value)
        except Exception:
            pass

    return None


def parse_json_array(text: Optional[str]) -> List[Dict[str, Any]]:
    if not text:
        return []
    try:
        data = json.loads(text)
    except Exception:
        return []
    if isinstance(data, list):
        return [x for x in data if isinstance(x, dict)]
    return []


def format_dt(dt: datetime) -> str:
    return dt.strftime("%Y-%m-%d %H:%M:%S")


def main() -> None:
    if len(sys.argv) != 3:
        print(
            "Usage: python3 scripts/export_ai_chat_from_db.py "
            '"/path/to/state.vscdb" "/path/to/output_dir"',
            file=sys.stderr,
        )
        sys.exit(1)

    db_path = sys.argv[1]
    out_dir = sys.argv[2]

    os.makedirs(out_dir, exist_ok=True)

    try:
        conn = connect_db(db_path)
    except Exception as e:
        print(f"Failed to open DB: {e}", file=sys.stderr)
        sys.exit(1)

    try:
        gen_text = get_key_value(conn, "aiService.generations")
        prom_text = get_key_value(conn, "aiService.prompts")
    finally:
        conn.close()

    generations = parse_json_array(gen_text)
    prompts = parse_json_array(prom_text)

    now_local = datetime.now(LOCAL_TZ)
    today = now_local.date()
    start_dt = datetime(today.year, today.month, today.day, 11, 0, 0, tzinfo=LOCAL_TZ)
    end_dt = datetime(today.year, today.month, today.day, 23, 0, 0, tzinfo=LOCAL_TZ)

    window_generations: List[Dict[str, Any]] = []
    for g in generations:
        ts_ms = g.get("unixMs")
        if not isinstance(ts_ms, (int, float)):
            continue
        dt_utc = datetime.fromtimestamp(ts_ms / 1000.0, tz=timezone.utc)
        dt_local = dt_utc.astimezone(LOCAL_TZ)
        if start_dt <= dt_local <= end_dt:
            g_copy = dict(g)
            g_copy["_dt_local"] = dt_local
            window_generations.append(g_copy)

    window_generations.sort(key=lambda x: x["_dt_local"])

    # 生成 Markdown
    lines: List[str] = []
    lines.append("<!-- Generated by export_ai_chat_from_db.py -->")
    lines.append("")
    lines.append(f"**Source DB**: `{db_path}`")
    lines.append("")
    lines.append(
        f"**时间范围（本地时区）**：{start_dt.strftime('%Y-%m-%d %H:%M')} ~ {end_dt.strftime('%Y-%m-%d %H:%M')}"
    )
    lines.append("")

    lines.append("### 从 aiService.generations 提取的提示（按时间过滤）")
    lines.append("")

    if not window_generations:
        lines.append("- **提示**：该时间段内未找到任何 generations 记录。")
    else:
        for idx, g in enumerate(window_generations, start=1):
            dt_str = format_dt(g["_dt_local"])
            uuid = g.get("generationUUID", "")
            text = (g.get("textDescription") or "").strip()
            header = f"- **消息 {idx}** · {dt_str}"
            if uuid:
                header += f" · UUID: `{uuid}`"
            lines.append(header)
            lines.append("")
            lines.append("```text")
            lines.append(text)
            lines.append("```")
            lines.append("")

    lines.append("")
    lines.append("### 来自 aiService.prompts 的命令文本（该结构无时间戳，无法精确按时间过滤）")
    lines.append("")

    if not prompts:
        lines.append("- **提示**：未找到 prompts 记录。")
    else:
        for idx, p in enumerate(prompts, start=1):
            text = (p.get("text") or "").strip()
            cmd_type = p.get("commandType")
            header = f"- **Prompt {idx}**"
            if cmd_type is not None:
                header += f" · commandType={cmd_type}"
            lines.append(header)
            lines.append("")
            lines.append("```text")
            lines.append(text)
            lines.append("```")
            lines.append("")

    short_id = os.path.basename(os.path.dirname(db_path))[:8]
    out_name = f"ai-chat-{today.strftime('%Y%m%d')}-1100-2300-{short_id}.md"
    out_path = os.path.join(out_dir, out_name)

    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))


if __name__ == "__main__":
    main()


