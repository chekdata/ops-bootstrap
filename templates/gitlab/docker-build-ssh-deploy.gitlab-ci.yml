stages:
  - build
  - deploy

# This template builds a Docker image using GitLab's Docker-in-Docker and deploys over SSH
# to a remote host by pulling the image and replacing the running container.
#
# Required protected variables per target environment (e.g., staging/prod):
# - DEPLOY_HOST: remote host IP or DNS (e.g., 172.31.44.122)
# - DEPLOY_USER: SSH user on remote (e.g., deploy)
# - DEPLOY_SSH_PRIVATE_KEY: private key for DEPLOY_USER
# - CONTAINER_NAME: unique container name on remote
# - DEPLOY_PORTS: comma-separated Docker -p mappings, e.g. "8080:8080,8443:8443"
# Optional variables:
# - ENV_VARS: space-separated env pairs (e.g., "NODE_ENV=production API_URL=https://api")
# - VOLUMES: space-separated -v pairs (e.g., "/data/logs:/app/logs /etc/localtime:/etc/localtime:ro")
# - NETWORK: docker network name to attach
# - HEALTHCHECK_URL: full URL to check after deploy for basic readiness
# - ADDITIONAL_RUN_ARGS: any extra docker run args
# - DOCKERFILE: custom Dockerfile path (default Dockerfile)
# - BUILD_CONTEXT: docker build context (default .)
# - IMAGE_TAG: tag override (default uses $CI_COMMIT_SHA)

.docker-variables:
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_VERIFY: "1"
    DOCKER_CERT_PATH: "/certs/client"
    DOCKER_BUILDKIT: "1"

.docker-services:
  services:
    - name: docker:dind
      command: ["--mtu=1460"]

build_image:
  stage: build
  image: docker:26.1.3
  extends:
    - .docker-variables
    - .docker-services
  script:
    - apk add --no-cache bash jq git
    - |
      : "${DOCKERFILE:=Dockerfile}"
      : "${BUILD_CONTEXT:=.}"
      IMAGE_REF="${CI_REGISTRY_IMAGE}:${IMAGE_TAG:-$CI_COMMIT_SHORT_SHA}"
      echo "Building image ${IMAGE_REF} with ${DOCKERFILE} (context ${BUILD_CONTEXT})"
      echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
      docker build -f "$DOCKERFILE" -t "$IMAGE_REF" "$BUILD_CONTEXT"
      docker push "$IMAGE_REF"
    - echo "IMAGE_REF=${CI_REGISTRY_IMAGE}:${IMAGE_TAG:-$CI_COMMIT_SHORT_SHA}" > image.env
  artifacts:
    reports:
      dotenv: image.env
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH

deploy_ssh:
  stage: deploy
  image: alpine:3.20
  needs: ["build_image"]
  environment:
    name: $CI_COMMIT_REF_NAME
  before_script:
    - apk add --no-cache openssh-client bash curl docker-cli
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - echo "$DEPLOY_SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa && chmod 600 ~/.ssh/id_rsa
    - |
      if [ -n "$DEPLOY_SSH_KNOWN_HOSTS" ]; then
        echo "$DEPLOY_SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
      else
        ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
      fi
  script:
    - |
      set -euo pipefail
      : "${DEPLOY_HOST?missing}"
      : "${DEPLOY_USER?missing}"
      : "${CONTAINER_NAME?missing}"
      : "${DEPLOY_PORTS?missing}"
      : "${IMAGE_REF?missing}"

      # Build docker run flags on the remote host
      RUN_PORTS=""
      IFS=',' read -ra PORTS_ARR <<< "$DEPLOY_PORTS"
      for mapping in "${PORTS_ARR[@]}"; do
        RUN_PORTS="$RUN_PORTS -p ${mapping}"
      done

      RUN_ENVS=""
      if [ -n "${ENV_VARS:-}" ]; then
        for kv in ${ENV_VARS}; do
          RUN_ENVS="$RUN_ENVS -e ${kv}"
        done
      fi

      RUN_VOLUMES=""
      if [ -n "${VOLUMES:-}" ]; then
        for vol in ${VOLUMES}; do
          RUN_VOLUMES="$RUN_VOLUMES -v ${vol}"
        done
      fi

      RUN_NETWORK=""
      if [ -n "${NETWORK:-}" ]; then
        RUN_NETWORK="--network ${NETWORK}"
      fi

      EXTRA_ARGS="${ADDITIONAL_RUN_ARGS:-}"

      REMOTE_SCRIPT=$(cat <<'EOS'
      set -euo pipefail
      echo "Using container: ${CONTAINER_NAME}"
      echo "Pulling image: ${IMAGE_REF}"
      docker pull "${IMAGE_REF}"
      if docker ps -a --format '{{.Names}}' | grep -Eq "^${CONTAINER_NAME}$"; then
        echo "Stopping and removing existing container ${CONTAINER_NAME}"
        docker rm -f "${CONTAINER_NAME}" || true
      fi
      echo "Starting new container ${CONTAINER_NAME}"
      # shellcheck disable=SC2086
      docker run -d --restart=always --name "${CONTAINER_NAME}" ${RUN_PORTS} ${RUN_ENVS} ${RUN_VOLUMES} ${RUN_NETWORK} ${EXTRA_ARGS} "${IMAGE_REF}"
      docker ps --filter name="${CONTAINER_NAME}" --format 'table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'
      EOS
      )

      echo "$REMOTE_SCRIPT" | ssh -o StrictHostKeyChecking=yes "${DEPLOY_USER}@${DEPLOY_HOST}" bash

      if [ -n "${HEALTHCHECK_URL:-}" ]; then
        echo "Waiting for healthcheck ${HEALTHCHECK_URL}"
        for i in $(seq 1 30); do
          if curl -fsS "$HEALTHCHECK_URL" >/dev/null 2>&1; then
            echo "Healthy"
            exit 0
          fi
          sleep 2
        done
        echo "Healthcheck failed"
        exit 1
      fi
  rules:
    - if: $CI_COMMIT_BRANCH


